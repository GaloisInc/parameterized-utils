------------------------------------------------------------------------
-- |
-- Module           : Data.Parameterized.NonceGenerator
-- Copyright        : (c) Galois, Inc 2014
-- Maintainer       : Joe Hendrix <jhendrix@galois.com>
--
-- This module provides a simple generator of new indexes in the ST monad.
-- It is predicatable and not intended for cryptographic purposes.
--
-- NOTE: the TestEquality and OrdF instances for the Nonce type simply
-- compare the generated nonce values and then assert to the compiler
-- (via unsafeCoerce) that the types ascribed to the nonces are equal
-- if their values are equal.
------------------------------------------------------------------------
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RoleAnnotations #-}
{-# LANGUAGE Trustworthy #-}
module Data.Parameterized.Nonce
  ( NonceGenerator
  , withIONonceGenerator
  , withSTNonceGenerator
  , freshNonce
  , Nonce
  , indexValue
  ) where

import Control.Monad.ST
import Data.Hashable
import Data.IORef
import Data.STRef
import Data.Word
import Unsafe.Coerce

import Data.Parameterized.Classes

-- | A simple type that for getting fresh indices in the ST monad.
-- The first type is used for the ST monad, the second is the type
-- used for the counter.
data NonceGenerator m s = NonceGenerator {
    freshNonce :: forall (tp :: k) . m (Nonce s tp)
  }

-- | Create a new counter.
withSTNonceGenerator :: (forall s . NonceGenerator (ST t) s -> (ST t) r) -> ST t r
withSTNonceGenerator f = do
  r <- newSTRef (toEnum 0)
  f $! NonceGenerator {
      freshNonce = do
          i <- readSTRef r
          writeSTRef r $! succ i
          return $! Nonce i
    }

-- | Create a new counter.
withIONonceGenerator :: (forall s . NonceGenerator IO s -> IO r) -> IO r
withIONonceGenerator f = do
  r <- newIORef (toEnum 0)
  f $! NonceGenerator {
      freshNonce = do
        i <- readIORef r
        writeIORef r $! succ i
        return $! Nonce i
    }

-- | An index generated by the counter.
newtype Nonce (s :: *) (tp :: k) = Nonce { indexValue :: Word64 }
  deriving (Eq, Ord, Hashable, Show)

--  Force the type role of Nonce to be nominal: this prevents Data.Coerce.coerce
--  from casting the types of nonces, which it would otherwise be able to do
--  because tp is a phantom type parameter.  This partially helps to protect
--  the nonce abstraction.
type role Nonce nominal nominal

instance TestEquality (Nonce s) where
  testEquality x y | indexValue x == indexValue y = unsafeCoerce (Just Refl)
                   | otherwise = Nothing

instance OrdF (Nonce s) where
  compareF x y =
    case compare (indexValue x) (indexValue y) of
      LT -> LTF
      EQ -> unsafeCoerce EQF
      GT -> GTF

instance HashableF (Nonce s) where
  hashWithSaltF s (Nonce x) = hashWithSalt s x

instance ShowF (Nonce s) where
  showF = show

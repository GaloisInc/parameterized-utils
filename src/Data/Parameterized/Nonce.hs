------------------------------------------------------------------------
-- |
-- Module           : Data.Parameterized.NonceGenerator
-- Copyright        : (c) Galois, Inc 2014
-- Maintainer       : Joe Hendrix <jhendrix@galois.com>
--
-- This module provides a simple generator of new indexes in the ST monad.
-- It is predicatable and not intended for cryptographic purposes.
--
-- NOTE: the TestEquality and OrdF instances for the Nonce type simply
-- compare the generated nonce values and then assert to the compiler
-- (via unsafeCoerce) that the types ascribed to the nonces are equal
-- if their values are equal.
------------------------------------------------------------------------
{-# LANGUAGE CPP #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE EmptyDataDecls #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RoleAnnotations #-}
{-# LANGUAGE Trustworthy #-}
{-# LANGUAGE TypeFamilies #-}
#if MIN_VERSION_base(4,9,0)
{-# LANGUAGE TypeInType #-}
#endif
module Data.Parameterized.Nonce
  ( NonceGenerator
  , withIONonceGenerator
  , withSTNonceGenerator
  , freshNonce
  , Nonce
  , indexValue
  , MonadNonce(..)
  , NonceT(..)
  , NonceST
  , NonceIO
  , getNonceSTGen
  , runNonceST
  , runNonceIO
  , GlobalNonceGenerator
  , globalNonceGenerator
  ) where

import Control.Monad.ST
import Control.Monad.Reader
import Control.Monad.State
import Data.Hashable
import Data.IORef
import Data.STRef
import Data.Typeable
import Data.Word
import Unsafe.Coerce
import System.IO.Unsafe (unsafePerformIO)

import Data.Parameterized.Classes

#if MIN_VERSION_base(4,9,0)
import Data.Kind
#endif

-- | A simple type that for getting fresh indices in the ST monad.
-- The first type is used for the ST monad, the second is the type
-- used for the counter.
data NonceGenerator (m :: * -> *) (s :: *) = NonceGenerator {
#if MIN_VERSION_base(4,9,0)
-- We have to make the k explicit in GHC 8.0 to avoid a warning.
    freshNonce :: forall k (tp :: k) . m (Nonce s tp)
#else
    freshNonce :: forall (tp :: k) . m (Nonce s tp)
#endif
  }

-- | Create a new counter.
withSTNonceGenerator :: (forall s . NonceGenerator (ST t) s -> (ST t) r) -> ST t r
withSTNonceGenerator f = do
  r <- newSTRef (toEnum 0)
  f $! NonceGenerator {
      freshNonce = do
          i <- readSTRef r
          writeSTRef r $! succ i
          return $! Nonce i
    }

-- | Create a new counter.
withIONonceGenerator :: (forall s . NonceGenerator IO s -> IO r) -> IO r
withIONonceGenerator f = do
  r <- newIORef (toEnum 0)
  f $! NonceGenerator {
      freshNonce = do
        i <- readIORef r
        writeIORef r $! succ i
        return $! Nonce i
    }

data GlobalNonceGenerator

globalNonceIORef :: IORef Word64
globalNonceIORef = unsafePerformIO (newIORef 0)
{-# NOINLINE globalNonceIORef #-}

-- | A nonce generator that uses a globally-defined counter
globalNonceGenerator :: NonceGenerator IO GlobalNonceGenerator
globalNonceGenerator =
  NonceGenerator
  { freshNonce = Nonce <$> atomicModifyIORef' globalNonceIORef (\n -> (n+1, n))
  }

-- | An index generated by the counter.
newtype Nonce (s :: *) (tp :: k) = Nonce { indexValue :: Word64 }
  deriving (Eq, Ord, Hashable, Show)

--  Force the type role of Nonce to be nominal: this prevents Data.Coerce.coerce
--  from casting the types of nonces, which it would otherwise be able to do
--  because tp is a phantom type parameter.  This partially helps to protect
--  the nonce abstraction.
type role Nonce nominal nominal

instance TestEquality (Nonce s) where
  testEquality x y | indexValue x == indexValue y = unsafeCoerce (Just Refl)
                   | otherwise = Nothing

instance OrdF (Nonce s) where
  compareF x y =
    case compare (indexValue x) (indexValue y) of
      LT -> LTF
      EQ -> unsafeCoerce EQF
      GT -> GTF

instance HashableF (Nonce s) where
  hashWithSaltF s (Nonce x) = hashWithSalt s x

instance ShowF (Nonce s) where
  showF = show

-- | A MonadNonce is a monad that can generate fresh 'None's in a given set
-- (where we view the phantom type parameter of 'Nonce' as a designator of the
-- set that the 'Nonce' came from)
class Monad m => MonadNonce m where
  type NonceSet m :: *
  freshNonceM :: forall (tp :: k) . m (Nonce (NonceSet m) tp)

-- | This transformer adds a nonce generator to a given monad
newtype NonceT s m a =
  NonceT { runNonceT :: ReaderT (NonceGenerator m s) m a }
  deriving (Functor, Applicative, Monad)

instance MonadTrans (NonceT s) where
  lift m = NonceT $ lift m

instance Monad m => MonadNonce (NonceT s m) where
  type NonceSet (NonceT s m) = s
  freshNonceM = NonceT $ lift . freshNonce =<< ask

instance MonadNonce m => MonadNonce (StateT s m) where
  type NonceSet (StateT s m) = NonceSet m
  freshNonceM = lift $ freshNonceM

-- | Helper type to build a 'MonadNonce' from the 'ST' monad
type NonceST t s = NonceT s (ST t)

-- | Helper type to build a 'MonadNonce' from the 'IO' monad
type NonceIO s = NonceT s IO

-- | Return the actual 'NonceGenerator' used in an 'ST' computation
getNonceSTGen :: NonceST t s (NonceGenerator (ST t) s)
getNonceSTGen = NonceT ask

-- | Run a 'NonceST' computation with a fresh 'NonceGenerator'
runNonceST :: (forall t s. NonceST t s a) -> a
runNonceST m = runST $ withSTNonceGenerator $ runReaderT $ runNonceT m

-- | Run a 'NonceIO' computation with a fresh 'NonceGenerator' inside 'IO'
runNonceIO :: (forall s. NonceIO s a) -> IO a
runNonceIO m = withIONonceGenerator $ runReaderT $ runNonceT m
